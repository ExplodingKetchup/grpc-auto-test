# gRPC Auto testing tool

## Summary
Languages used for testing: Java, NodeJs, Python.

Conducted tests and inconsistencies are found in tests.xlsx. Inconsistencies are in 'Active issues' sheet.

## Terminologies
- **Analyzer result file (analyzer file)**: File containing "actual" (from output files) and "expected" (from registry) messages, metadata, and grpc exceptions, as well as comparison results. Produced by CoreService.
- **Config**: Refers to the configurations in CoreService, stored in application.properties. These configs are not likely to change between each run (compare to 'setup script' below).
- **CoreService**: Main program; responsible for managing settings and test cases, launching tests and analyze results.
- **gRPC exceptions**: Exceptions raised by gRPC and sent to the other party. Includes: Status code, description, and trailing metadata (see https://grpc.io/docs/guides/error/).
- **Message id**: Full name of the message, e.g. `package.message`.
- **Metadata**: Refers to the metadata attached to a gRPC call (see https://grpc.io/docs/guides/metadata/).
  - **Header metadata (headers)**: Metadata sent before the 1st request (if sent from client), or before the 1st response (if sent from server).
  - **Trailing metadata (trailers)**: Metadata sent by the server when it closes the gRPC call.
- **Method id**: Full name of the method, e.g. `package.service.method`.
- **Output files**: files produced by test programs, recording received messages, metadata, and gRPC exceptions.
- **Registry**: Objects holding information about the test (testcases, RPC definitions, etc.). These objects are created and managed by the CoreService and is only applicable for the current instance of test (i.e. not persisted between each run of CoreService).
- **Service id**: Full name of the service, e.g. `package.service`.
- **Setup script**: A text file containing the configs for the next run (you can consider this as user input). Not to be mistaken with configs: setup script configs are likely to change between runs, while configs are usually fixed. 
- **Test cases**: Test messages sent and received between test programs to test gRPC communication. Sometimes, test cases also contain gRPC exceptions to be raised by the server. There are 2 types of test cases:
  - **Generated test cases**: Generated by CoreService based on several settings.
  - **Custom test cases**: Defined by users.
- **Test programs**: Sub-programs launched by CoreService used for testing gRPC. They will be the ones directly making gRPC calls and record the results.

## Introduction
grpc-auto-test is a program designed to automatically generate source code, build and deploy test programs. Specifically it can work with gRPC using Protobuf as the underlying serializing protocol.

The test will target gRPC implementation for 3 languages: **Java**, **NodeJS**, and **Python**.

Overview of how grpc-auto-test works:
1. Read user settings, service and messages definitions (from .proto files), and custom test cases (if available).
2. Generate random messages, metadata, etc. if necessary.
3. Write the test messages to be sent and received by test programs to binary files (using protobuf). We will refer to these messages as "test cases".
4. Generate source code of test programs from templates (using Freemarker).
5. Build and deploy test programs as Docker container running within a Docker Compose project. A container for client service and a container for server service will be created.
6. The client will read test cases and use these messages as parameter to invoke gRPC call against the server.
7. The server, upon receiving messages from the client, also reads test cases and return those messages as response to client.
8. Both the client and server will record messages they receive from the other party (recorded in logs, and in the output folder as protobuf-encoded messages).
9. CoreService retrieves output files and compare them with the registry.
10. CoreService outputs analyzer file.

## Directory Structure

We only note important files here to be concise.

### grpc-auto-test
Home directory

### grpc-auto-test/core
Source code of CoreService.
- `core/src/main/java/org/grpctest/core/Application.java`: Entry point of CoreService.
- `core/src/main/java/org/grpctest/core/service`: Service package. All sub-services of CoreService are here.
  - `core/src/main/java/org/grpctest/core/service/CoreService.java`: Main application logics (in afterPropertiesSet method).
  - `core/src/main/java/org/grpctest/core/service/ResultAnalyzer.java`: Analyzer service.
- `core/src/main/resources/code-templates`: Templates used to generate source code for test programs.
- `core/src/main/resources/proto`: Put .proto files here. CoreService will check this place for proto definitions
- `core/src/main/resources/tests`: CoreService will check this place for custom test cases.
- `core/src/main/resources/application.properties`: Config file for CoreService. See configs.xlsx for details.

### grpc-auto-test/java
Source code of Java test program.

### grpc-auto-test/nodejs
Source code of NodeJs test program.

### grpc-auto-test/python
Source code of Python test program.

### grpc-auto-test/log
Log folder. Log files are named as follows:
- CoreService: core.log (older logs: core.yyyy-mm-dd.log)
- Java client: java-client.log (older logs: java-client.yyyy-mm-dd.log)
- Java server: java-server.log (older logs: java-server.yyyy-mm-dd.log)
- NodeJs client: node-client.yyyy-mm-dd.log
- NodeJs server: node-server.yyyy-mm-dd.log
- Python client: py-client_<Unix_timestamp>.log
- Python server: py-server_<Unix_timestamp>.log

Note that the date/time here are in UTC timezone

### grpc-auto-test/out
- `grpc-auto-test/out/analyzer`: Contains analyzer files (analyzer files are named `analyzer_out_yyMMdd_HHmmss.txt`)
- `grpc-auto-test/out/client`: Contains output files from client.
- `grpc-auto-test/out/server`: Contains output files from server.

### grpc-auto-test/setup
Contains the setup script (see (#setup-script)).

### grpc-auto-test/test-cases
Contains test messages (encoded to binary form using Protobuf). Test programs will read from this place to form messages to send to the other party.

### grpc-auto-test/compose.yaml
Docker compose file specifying all services for test programs, plus mounts and networks between those services.

### configs.xlsx
Records all available configs.

### DEVNOTES
Notes regarding grpc-auto-test.

### NOTES
Temporary notes for me. You may ignore this file.

### tests.xlsx
Records all conducted tests and their results, including any inconsistencies found (see 'Active issues' inside the file).

### TODO
Future directions for development and testing.

## Running the Application

### Dependencies
Note that these are the versions we tested this application with. You do not need the exact same versions to run this app.

#### Languages version:
- Java: 21
- NodeJs: 23.0.0
- Python: 3.13

#### Docker
Docker version 27.4.0, build bde2b89 on MacOS.

Make sure that 'docker' and 'docker compose' commands are available and accessible to the app.

#### Maven
Apache Maven 3.9.6 on MacOS.

Make sure that 'mvn' command is available and accessible to the app.

#### Steps to launch app
1. Build CoreService
```shell
$ cd core
$ mvn clean package -DskipTests
```
2. Run CoreService
```shell
$ cd ../  # Go back to home directory
$ java -jar path_to_built_jar_file
```

Note: This app is only tested on MacOS, so it might have problems running on Windows, especially due to different file separator and/or different commands to invoke for maven and docker. If possible, please run it on a Unix-based OS. We are working on containerizing the app.

Remember to launch this app with the `grpc-auto-test/` as the working directory (otherwise the intended file location will be messed up).

## Setup script
The setup script should be named `setup.txt` and placed in `grpc-auto-test/setup` (You can change this in the configs).

Below is the options you can put in (You could also check `core/src/main/java/org/grpctest/core/service/ui/SetupScriptInterpreter.java` under `Option`).
Each option must be on a single line, and must be in the form `<KEYWORD> [<arg>...]`, and arguments are not order-sensitive. Each line in the paragraph below is an option:

```text
CLIENT { JAVA | NODEJS | PYTHON }
SERVER { JAVA | NODEJS | PYTHON }
TESTCASE [value_flag] [<custom_testcase.json>...]
[ COMPRESSION [<compression_flag>...] ]
[ METADATA [<header_flag>...] ]
[ MOCK_EXCEPTION ]
[ INCLUDE_PROTO [<proto_definition.proto>...]
[ GENERATE_FILES_ONLY ]
```

Where:<br>
Flags are in the form `--key:value`.<br>
- `value_flag`: 
  - `key` = `random` or `default`
  - `value` = `0`, `1`, or `2`
- `compression_flag`
  - `key` = `request` or `response`
  - `value` = `gzip` or `deflate`
- `header_flag`:
  - `key` = `client-server` or `server-client`
  - `value` = `STRING` or `BIN`

`CLIENT`: Specify language for client test program.
`SERVER`: Specify language for server test program.
`TESTCASE`:<br> 
By enabling `value_flag`, we enabled testcase generation. Testcase generation generates random testcases or 
testcases with default values (depending on the key of `value_flag`).
With testcase generation, we can specify if the program should generate value for every fields (`value_flag` value = 0),
or generate value for some of the fields (`value_flag` value = 1), or generate empty messages (`value_flag` value = 2).<br>
You can also specify custom test cases here. See (#custom-test-cases) for the syntax.<br>
`COMPRESSION`: Specify whether to use compression on requests and responses. **(UNTESTED FEATURE)**<br>
`METADATA`: Send test headers (randomly generated) with each call. In a run, the set of headers is identical between
each call. `client-server` refers to client-to-server headers, and `server-client` refers to server-to-client ones.
`header_flag` value refers to the data type of the headers (ASCII string or binary).<br>
`MOCK_EXCEPTION`: Server will raise gRPC exceptions in the calls.
`INCLUDE_PROTO`: Specify which .proto files should be included for service and message definition. If not specify, will
include everything found in CoreService's `resources/proto`.
`GENERATE_FILES_ONLY`: Only generates testcases, testcase binaries, and test program code. Will not build and launch test
programs, and do not analyze results.

## proto files definition
We have not tested with proto2 protobuf syntax, only proto3.

Please include this in the proto definition:
```protobuf
option java_multiple_files = true;
option java_package = "org.grpctest.java.common.define";
option java_outer_classname = "DefaultDataProto";
```

## Custom test cases
Custom test cases should be in a JSON file as follows:
```json
{
  "name": "RPC test",
  "methodId": "package.service.method",
  "paramValue": [
    {
      "field_name": <value>,
      ...
    },
    ...
  ],
  "returnValue": [
    {
      "field_name": <value>,
      ...
    },
    ...
  ],
  "exception": {
    "statusCode": "ERROR_STATUS",
    "description": "error description",
    "trailers": {
      "key1": "STRvalue1",
      "key2": "BIN0123456789abcdef"
    },
    "runtimeException": false
  }
}
```

Explanations:

- `name`: name of the testcase (optional).
- `methodId`: the method that the test case will be mapped to.
- `paramValue`: array of request messages (field_name is the same as defined in .proto file).
- `returnValue`: array of response messages.
- `value` depends on the type of the field:
  - float / double: real number (if it is an integer, you could put '.0' at the end to avoid errors)
  - integer types: integer number
  - bool: true/false
  - string: a string
  - bytes: a string of hex values (e.g. "02ae5f")
  - enum: name of the enum value or value of the enum value (e.g. "ENUM_ONE" or 1)
  - composite type (another message type): same as a normal message
- `exception`:
  - `statusCode`: name of the gRPC status code except 'OK' (see https://grpc.github.io/grpc-java/javadoc/io/grpc/Status.Code.html)
  - `description`: a string describing the error
  - `trailers`: trailers to attach to the exception
    - The value (right hand side) of the metadata could be any string (in this case it will be interpreted as a String metadata). If it starts with "STR", then it considered a string metadata, and the "STR-" prefix will be ignored. If it starts with "BIN", then the metadata is interpreted as a binary type, and the rest of the string must be a hex string of the bytes value.
  - `runtimeException`: boolean. In Java, there's the option to raise the exception as runtime exception or not, but we have not tested what effects that will have on the other languages, or their equivalents in other languages, so it is recommended to just put "false".

You can check the files in CoreService's `resources/tests` for examples.

## Test results
See tests.xlsx for details.

## Limitations
- 1 Server / Client instance per run
- 1 testcase per RPC method
- Dockerfiles and compose.yaml cannot be generated at runtime
- Path-related configs should not be changed
- gRPC exceptions only include server-raised exceptions
- Not tested on Windows yet
- The app is not portable yet: the working directory when launching CoreService must be grpc-auto-test home directory

## Future developments
- RPC call with compression
- RPC call with authentication
- Test other options of protobuf message definition (e.g. Map type, packed repeated fields)
- Test with proto2 syntax
- Containerize CoreService

(See TODO for more, although the ones listed here have the highest priority)